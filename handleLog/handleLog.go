package main

import (
	"bufio"
	"crypto/md5"
	"encoding/hex"
	"flag"
	"fmt"
	"github.com/mgutz/str"
	"io"
	"log"
	"net/url"
	"os"
	"strings"
	"time"
)

/**
  解析日志文件，将 一行日志拆分为多个有一定意义的片段，再由对应的 函数处理，入库，提供数据支持，后续根据这些数据进行统计，并实现可视化分析。
*/
type cmdData struct {
	filePath   string
	routineNum int
}

type digData struct {
	url   string
	time  string
	agent string
	refer string
}

type userData struct {
	data digData
	uid  string
}

func init() {
}

func main() {
	//1、 获取命令行参数，记录日志
	filePath := flag.String("filePath", "/var/log/nginx/dig.log", "parse file's path")
	routineNum := flag.Int("routineNum", 5, "the count of routine in handle log")
	//logDir:=flag.String("logDir","/home/martin/log/","the logFile's dir generated by this exe")
	flag.Parse()

	var cmd = cmdData{*filePath, *routineNum}

	//2、 初始化一些channel，用于数据传递
	var logChan = make(chan string, 3**routineNum)
	var pvChan = make(chan userData, *routineNum)
	var uvChan = make(chan userData, *routineNum)
	//var storageChan = make(chan stroageBlock, *routineNum)

	// open log file
	file, err := os.OpenFile(cmd.filePath, os.O_RDONLY, 0644)
	if err != nil {
		fmt.Println("open file failed ,error=", err)
	}
	defer file.Close()
	//3、 日志消费者
	go readLogFile(file, logChan)
	for i := 0; i < *routineNum; i++ {
		go logConsumer(logChan ,pvChan,uvChan)
	}
	//4、 创建PV，UV 统计器
	go pvCounter(logChan, pvChan)
	go uvCounter(logChan, uvChan)
	//5、 创建存储器


	// 暂时 用 debug用
	time.Sleep(1000*time.Second)
}

func logConsumer(logChan <-chan string, pvChan chan<- userData, uvChan chan<- userData) {
	for log:= range logChan{
		digdata := parseLog(log)
		//uid: 模拟uid <==> md5(refer+agent)
		hash := md5.New()
		hash.Write([]byte(digdata.refer+digdata.agent))
		uid:=hex.EncodeToString(hash.Sum(nil))
		userdata:=userData{digdata,uid}
		fmt.Printf("%#v\n",userdata)
		pvChan<-userdata
		uvChan<-userdata
	}
}
/*
	解析日志，将一行日志解析 digData结构体
	日志实例：
		127.0.0.1 - - [10/Nov/2020:21:27:52 +0800] "GET /dig?agent=Mozilla%2F5.0+%28Windows+NT+10.0%3B+Win64%3B+x64%29+AppleWebKit%2F537.36+%28KHTML%2C+like+Gecko%29+Chrome%2F86.0.4240.183+Safari%2F537.36&refer=http%3A%2F%2Flocalhost%3A88%2Fgxcms%2Fmovie%2F7791.html&time=%EF%BF%BD&url=http%3A%2F%2Flocalhost%3A88%2Fgxcms%2Fmovie%2F2972.html HTTP/1.1" 200 43 "http://localhost:88/" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.183 Safari/537.36" "-"

*/
func parseLog(log string) digData  {
	paraBegin := "GET"
	paraEnd := "HTTP/"
	log = strings.TrimSpace(log)
	paraIndexStart := str.IndexOf(log, paraBegin, 0)+len(paraBegin)+1
	paraIndexEnd := str.IndexOf(log, paraEnd, paraIndexStart)-1
	paraStr :=str.Slice(log,paraIndexStart,paraIndexEnd)
	parse, err := url.Parse("http://localhost" + paraStr)
	if err != nil {
		return digData{}
	}
	values := parse.Query()
	return digData{values.Get("url"), values.Get("time"),values.Get("agent"),values.Get("refer")}
}
func uvCounter(logChan chan string, uvChan chan userData) {

}

func pvCounter(logChan chan string, pvChan chan userData) {

}

func readLogFile(file *os.File, logChan chan<- string) {
	reader := bufio.NewReader(file)
	for {
		readString, err := reader.ReadString('\n')
		if err != nil {
			if err == io.EOF {
				logChan <- readString
				close(logChan)
				return
			}
			log.Fatal("read  log filed,error:", err)
			break
		}
		logChan <- readString
	}

}
